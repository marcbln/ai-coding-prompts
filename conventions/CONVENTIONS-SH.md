# CONVENTIONS_SH.md

## Overview

This document defines the coding standards for Bash scripts generated by AI. These conventions aim to improve script readability, maintainability, portability, and reliability.

- Always use the following shebang for maximum portability:

```bash
#!/usr/bin/env bash
```

- Enable strict error handling and safety modes at the beginning of the script:

```bash
set -euo pipefail
```

- add comments to the script explaining what each option does:
```bash
# `-e`: Exit immediately if a command exits with a non-zero status
# `-u`: Treat unset variables as an error
# `-o pipefail`: Return the exit status of the last command in a pipeline that failed
```


- Include comprehensive doc header at the top of each script:

```bash
#!/usr/bin/env bash
# script-name.sh - Concise description of script purpose
# YYYY-MM-DD created
# YYYY-MM-DD last modified
#
# Detailed description of script functionality
# Author: [Optional: Author Name or AI Model]
# Version: [Optional: Version Number]
```

- Write clear, concise comments explaining complex logic
- Explain **why** something is done, not just **what**
- Use `#` for inline comments and `# ---- ` for section comments
- each script should have at lease `-h|--help` cli flags and a `usage` function

- Document each function with a comment block:

```bash
# Short description of function purpose
#
# Detailed explanation of function behavior
#
# Arguments:
#   $1 - First argument description
#   $2 - Second argument description
#
# Returns:
#   0 on success, non-zero on failure
#
# Example:
#   function_name "arg1" "arg2"
function_name() {
    # Function implementation
}
```

- use `# TODO:` for planned improvements or pending tasks:

```bash
# TODO: Implement error logging mechanism
# TODO: Add support for additional file types
```

- Use `UPPERCASE_WITH_UNDERSCORES` for constants and global variables
- Use `snake_case` for local variables
- Prefix internal/private variables with an underscore: `_internal_var`
- Always quote variables to prevent word splitting and globbing
- Use `readonly` for constants
- Prefer `local` for function-scoped variables

```bash
readonly CONFIG_DIR="/etc/myapp"
local current_file="$1"
```



### 4.3 Default Values
Use parameter expansion for providing default values:

```bash
log_level="${LOG_LEVEL:-info}"
config_path="${1:-/default/path}"
```

## 5. Functions

### 5.1 Function Design
- Keep functions small and focused
- Aim for single responsibility
- Prefer pure functions when possible

### 5.2 Return Values
- Use `return` for status codes (0 for success, non-zero for errors)
- Use command substitution `$()` for returning output

```bash
get_timestamp() {
    date "+%Y-%m-%d %H:%M:%S"
}

current_time=$(get_timestamp)
```

## 6. Control Flow

### 6.1 Conditionals
- Use `[[ ]]` for tests (Bash-specific, more powerful)
- Prefer `==` for string comparisons
- Use `-eq`, `-ne`, etc., for integer comparisons

```bash
if [[ "$string" == "expected_value" ]]; then
    # action
fi

if [[ "$number" -gt 10 ]]; then
    # action
fi
```

### 6.2 Loops
- Use `for` loops with safe practices
- Quote variables in loops

```bash
for file in "${files[@]}"; do
    process_file "$file"
done
```

## 7. Input and Output

### 7.1 User Communication
- Use `echo` for standard output
- Use `printf` for formatted output
- Redirect errors to `stderr`

```bash
echo "Processing complete"
printf "Processing file: %s\n" "$filename"
echo "Error: Invalid input" >&2
```

## 8. Error Handling

### 8.1 Exit Codes
Define and document meaningful exit codes:

```bash
# Exit Codes:
#   0 - Success
#   1 - General error
#   2 - Misuse of shell commands
#   126 - Command invoked cannot execute
#   127 - Command not found
#   128 - Invalid argument to exit
#   130 - Script terminated by Control-C
```

### 8.2 Error Traps
Consider using traps for cleanup:

```bash
cleanup() {
    # Remove temporary files, close connections, etc.
    rm -f "$temp_file"
}
trap cleanup EXIT ERR
```

## 9. Performance and Portability

### 9.1 External Commands
- Minimize use of external commands
- Use built-in commands when possible
- Check command availability before use

### 9.2 Compatibility
- Avoid bashisms if cross-shell compatibility is needed
- Test scripts with `shellcheck`

## 10. Testing and Validation

### 10.1 Self-Test Mode
Include a self-test mechanism:

```bash
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    # Script is being run directly, not sourced
    main "$@"
fi
```

### 10.2 Input Validation
Validate and sanitize all inputs:

```bash
validate_input() {
    [[ -z "$1" ]] && { echo "Error: Input cannot be empty" >&2; return 1; }
    # Additional validation logic
}
```

## 11. Security Considerations

- Avoid using `eval`
- Be cautious with user-supplied input
- Use `readonly` for critical variables
- Implement proper input validation

## Conclusion

Following these conventions will result in more robust, readable, and maintainable Bash scripts.

**Note:** Always use `shellcheck` to further validate your scripts against best practices.
